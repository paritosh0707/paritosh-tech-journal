> ⏱️ Estimated reading time: 15 min

When you first hear the term **Immediately Invoked Function Expression (IIFE)**, it may sound complicated. In reality, the idea is straightforward: you define a function and run it immediately. No later calls, no waiting — just define and execute in one go.

---

## Why Use an IIFE?

```javascript
// Regular function definition and call
function setup() {
  console.log("Application is ready.");
}
setup();
```

You might ask: why bother with a new structure when we can do the above? The answer lies in **two strong motivations**:

1. **Immediate Setup Actions**  
    Certain logic must run as soon as the program starts — for example, initializing a **database connection** or preparing environment settings.
    
2. **Avoiding Global Scope Pollution**  
    This is the _most important reason_ (and a common interview favorite).  
    JavaScript has a single global scope by default. Variables declared there are visible everywhere, which can lead to conflicts. By wrapping code in an IIFE, we create an isolated scope where variables can live without leaking into the global context.
    

??? info "Background: Global Scope vs Local Scope"

    Think of the global scope as a shared family living room. If everything is kept there, even children can grab what elders left lying around. IIFEs keep things tidy by creating private “rooms” for variables.

---

## Syntax of an IIFE

An IIFE is made of two parts:

1. **Function Wrapper** – The function is wrapped inside parentheses `()` so that JavaScript treats it as an _expression_, not a declaration.
    
2. **Execution Call** – Immediately after the wrapper, another `()` invokes it.
    

```javascript
(function () {
  console.log("DB connect");
})();
```

Output:

```
DB connect
```

---

## Variations of IIFE

There are different ways to write an IIFE:

### 1. Unnamed (Simple) IIFE

```javascript
(function () {
  console.log("Simple IIFE");
})();
```

### 2. Named IIFE

```javascript
(function initApp() {
  console.log("Named IIFE");
})();
```

Even though the function has a name (`initApp`), it still runs immediately.

### 3. Arrow Function IIFE

```javascript
(() => {
  console.log("Arrow function IIFE");
})();
```

??? tip "When to use Named vs Unnamed?"  

    Use a **named IIFE** if you want stack traces in debugging to show a clear function name. Otherwise, stick with simple unnamed ones.

---

## Passing Parameters to an IIFE

Just like normal functions, IIFEs can accept arguments:

```javascript
(function (name) {
  console.log(`DB connect for ${name}`);
})("Paritosh");
```

Output:

```
DB connect for Paritosh
```

Notice how the parameter is declared inside the wrapper and the value is passed during immediate invocation.

---

## The Critical Semicolon Issue

A tricky pitfall arises when writing multiple IIFEs back to back.

```javascript
(function () {
  console.log("First IIFE");
})()   // <-- semicolon missing
(function () {
  console.log("Second IIFE");
})();
```

This may cause JavaScript to misinterpret where one statement ends and the next begins.

!!! note "The Fix"  
    Always terminate each IIFE with a semicolon:

    ```javascript
    (function () {
      console.log("First IIFE");
    })();  // semicolon here

    (function () {
      console.log("Second IIFE");
    })();
    ```

---

## Summary

- **IIFE** = a function that executes immediately after definition.
    
- Useful for:
    
    - Startup/setup logic.
        
    - Avoiding pollution of the global scope.
        
- Syntax: `(function () { ... })();`
    
- Can be **unnamed, named, or arrow functions**.
    
- Parameters and arguments work the same as regular functions.
    
- Always **use semicolons** to separate consecutive IIFEs.
    

---

## Exercises

1. Write an IIFE that prints your name.
    
2. Modify it to accept your name as a parameter.
    
3. Create two IIFEs in the same file — one for initialization and one for logging — and test what happens when you forget the semicolon.
    
