> ⏱️ Estimated reading time: 20 min

## Introduction to Iterations

When we finished our discussion on control flow—covering `if/else`, `switch`, and ternary operators—we had the ability to **control decisions** in a program. Now, we take a natural next step: controlling **repetition**.

In programming, repeating an action is just as fundamental as making a decision. Whether it’s **reading rows from a dataset**, **iterating over API responses**, or **processing multiple user inputs**, you rarely execute code only once. This is where loops—or, more formally, **iterations**—enter the picture.

### Why Iterations Matter

By this stage, you’ve already worked through JavaScript foundations: **functions, objects, and arrays**. That means you’re equipped with building blocks. Loops simply let you apply those blocks multiple times, with different inputs, until a condition says _stop_.

Unlike control structures that branch execution, **loops control repetition**. And in practice, that’s what makes them powerful—your code doesn’t have to be written ten times to process ten items.

### Practical vs. Academic Uses

In many programming classes, loops are introduced with exercises like printing star patterns or checking palindromes. While these help practice syntax, they don’t always prepare you for real-world tasks.

For us, the focus is practical:

- Iterating through **arrays of data** (e.g., stock prices, user IDs, or product lists).
    
- Repeating **API requests** until a certain condition is met.
    
- Running through **database rows** to transform or clean values.
    

These examples reflect how developers and data scientists truly rely on loops.

### Terminology

The word **loop** is most common, but you might also hear:

- **Iterations** – emphasizing the repeated cycles of execution.
    
- **Iterators** – a more technical term, especially relevant when we discuss ES6+ features like `for...of` and custom iterator objects.
    

For now, consider them synonyms, with small differences in technical usage that we’ll revisit later.

### Programming Principle

One principle you’ll see repeated in programming is:

> _There are always multiple ways to accomplish the same task._

Loops are no exception. JavaScript gives us several ways to repeat actions, from the classic `for` loop to `while`, `for...of`, and even array methods like `.map()` and `.forEach()`. Choosing the right loop depends on readability, performance, and the problem at hand.

---

??? info "Did you know?"  
	In Python, Java, C, and JavaScript, the **`for` loop syntax** is almost identical. Learning it once makes it transferable across multiple languages.

---

## The Basic `for` Loop Structure and Execution Flow

The `for` loop is the **workhorse of iteration** in JavaScript. If you’ve seen loops in Python, Java, or C, you’ll find the structure almost identical. This familiarity makes the `for` loop an easy entry point into mastering iterations.

### Printing a Simple Sequence

The most direct way to understand a loop’s mechanics is to print a sequence of numbers. For example, counting from 1 to 10:

```javascript
for (let index = 1; index <= 10; index++) {
    console.log(index);
}
```

This code outputs the numbers 1 through 10, one per line. While this may look trivial, it captures the essence of looping: **repeat until a condition tells you to stop.**

---

### Scope and Block

The curly braces `{}` of a `for` loop define a **block scope**. Any variable declared inside this block with `let` or `const` is local to the loop. For instance:

```javascript
for (let index = 0; index < 3; index++) {
    let message = "Inside loop";
    console.log(message);
}

console.log(typeof message); // "undefined"
```

Here, `message` is inaccessible outside the loop because it lives only inside the loop’s block scope.

---

### The Three Parts of the `for` Loop

The `for` loop header is structured into **three critical components**, separated by semicolons:

```javascript
for (initialization; condition; update) {
    // loop body
}
```

1. **Initialization** – happens once at the start.
    
    ```javascript
    let index = 0;
    ```
    
2. **Condition Check** – evaluated before each iteration.
    
    ```javascript
    index < 10
    ```
    
    If the condition is `true`, the loop body executes; if `false`, the loop ends.
    
3. **Increment/Decrement** – executed after each iteration.
    
    ```javascript
    index++
    ```
    

Because of this flow, control in a `for` loop feels a bit “jumpy”: it moves from initialization → condition → body → update → condition → body → … until the condition fails.

---

### Execution Flow Recap

- **Start:** Initialize variable.
    
- **Check Condition:** If true, enter the loop body.
    
- **Execute:** Run the code inside `{ }`.
    
- **Update:** Apply increment/decrement.
    
- **Repeat:** Jump back to the condition check.
    
- **Exit:** If condition is false, jump completely out of the loop.
    

---

### Loop Termination

A loop ends naturally when the condition fails. For example:

```javascript
for (let index = 0; index < 5; index++) {
    console.log(index);
}
```

When `index` becomes 5, the condition `index < 5` is false, and the loop exits without running the body.

---

### Naming Conventions

You’ll often see developers shorten `index` to simply `i`. This is a long-standing tradition in programming. For nested loops, `i`, `j`, and `k` are commonly used:

```javascript
for (let i = 0; i < 5; i++) {
    console.log("Iteration:", i);
}
```

While shorthand is convenient, in real projects, **use descriptive names** when the loop variable has meaning (e.g., `userIndex`, `rowNumber`).

---

??? tip "Best Practice"  
	Use `let` for loop variables. If you mistakenly use `var`, the variable will not respect block scope and may cause hard-to-track bugs.

---

## Advanced `for` Loop Concepts

Once you’re comfortable with the mechanics of the `for` loop, the next step is to combine it with other control structures and even nest loops inside each other. This opens the door to solving more complex problems.

---

### Mixing Loops with Control Flow

Loops often need decision-making inside them. For example, suppose you want to print only the **even numbers** from 1 to 10. You can combine an `if` condition inside the loop:

```javascript
for (let i = 1; i <= 10; i++) {
    if (i % 2 === 0) {
        console.log("Even number:", i);
    }
}
```

Here, the loop runs through all numbers, but the `if` condition filters the output. This pattern—**iteration plus condition**—is one of the most common constructs in real-world applications, such as filtering data or validating inputs.

---

### Nested Loops

A **nested loop** is simply a loop inside another loop. This structure is essential when dealing with **two-dimensional data**, like grids, tables, or matrices.

```javascript
for (let i = 1; i <= 3; i++) {
    for (let j = 1; j <= 3; j++) {
        console.log(`i = ${i}, j = ${j}`);
    }
}
```

#### Execution Visualization

- The **outer loop (`i`)** runs once.
    
- For each outer loop cycle, the **inner loop (`j`)** runs through all its iterations.
    
- Only when the inner loop completes does the outer loop move to its next iteration.
    

---

### Scope Consideration

When nesting loops, each loop variable must have its own identity. For example:

```javascript
for (let i = 1; i <= 3; i++) {
    for (let j = 1; j <= 3; j++) {
        console.log(i, j);
    }
}
```

Here, `i` belongs to the outer loop, and `j` belongs to the inner loop. If you reused `i` in both places, the inner loop would interfere with the outer loop, creating logic errors.

---

### Practical Use: Multiplication Table

Nested loops shine in structured outputs. For example, printing a multiplication table up to 10x10:

```javascript
for (let i = 1; i <= 10; i++) {
    let row = "";
    for (let j = 1; j <= 10; j++) {
        row += (i * j).toString().padStart(4, " ");
    }
    console.log(row);
}
```

This produces a neatly aligned multiplication table in the console, where the outer loop controls the **rows** and the inner loop fills the **columns**.

---

??? info "Real-world Relevance"  
    Nested loops appear in many areas of programming:  
    - Iterating over rows and columns in a dataset  
    - Processing pixels in image data  
    - Running through combinations of options in simulations

---

## Looping Over Arrays

Arrays are everywhere in JavaScript. Whether you’re working with a list of users, product IDs, or dataset rows, you’ll almost always need to **iterate through an array**. The `for` loop adapts naturally for this purpose.

---

### Iterating Through an Array

Let’s say we have an array of numbers:

```javascript
const numbers = [10, 20, 30, 40, 50];

for (let index = 0; index < numbers.length; index++) {
    console.log(numbers[index]);
}
```

This loop prints each element in the array. Notice the pattern:

- The loop starts at `index = 0` (first element).
    
- It runs as long as `index < numbers.length`.
    
- Each cycle, it accesses `numbers[index]` and then increments `index`.
    

---

### Why Not Use `<=`?

Since array indexing starts at 0, the last element in the array is at `length - 1`. If you mistakenly write `<=` instead of `<`, you’ll try to access one step beyond the array:

```javascript
for (let index = 0; index <= numbers.length; index++) {
    console.log(numbers[index]);
}
```

The final iteration attempts to access `numbers[5]`, which does not exist. JavaScript will return:

```text
10
20
30
40
50
undefined
```

While not a crash, this `undefined` is still a bug.

---

### Error Handling and Behavior

Unlike some other languages (such as Java or C++), JavaScript does not throw an **out-of-bounds exception** when you access an invalid index. Instead, it silently returns `undefined`.

!!! note  
    This “silent failure” can be dangerous. If your code depends on valid values, always make sure your loop condition is precise.

---

### The Role of Increment

The increment step is crucial. If you forget it, the loop may run forever:

```javascript
for (let index = 0; index < numbers.length;) {
    console.log(numbers[index]);
    // missing index++ !
}
```

Here, `index` never increases. The condition `index < numbers.length` stays `true` forever, and the program hangs in an **infinite loop**.

---

### Practical Example

Suppose you’re processing a list of usernames:

```javascript
const users = ["Paritosh", "Ananya", "Ravi", "Meera"];

for (let i = 0; i < users.length; i++) {
    console.log(`Welcome, ${users[i]}!`);
}
```

This is far more practical than abstract star patterns: real-world code often involves looping over arrays to send messages, process data, or fetch records.

---

??? tip "Shortcut"  
    While the classic `for` loop works perfectly, JavaScript also provides modern alternatives like `for...of` and array methods (`.forEach`, `.map`, `.filter`).  
    We’ll explore those in upcoming sections.

---

## Controlling Loop Flow: `break` and `continue`

In real-world scenarios, you don’t always want a loop to run through **all** its iterations. Sometimes you need to **stop early**, and sometimes you just need to **skip certain cycles**. JavaScript provides two keywords for this purpose: `break` and `continue`.

---

### The Need for Early Exit

Imagine you have a dataset with 1000 results, but you only want to display the first 5. Instead of processing the entire dataset unnecessarily, you can stop the loop after 5 iterations using `break`. This makes your code both faster and cleaner.

---

### The `break` Keyword

- **Function:** Immediately ends the loop.
    
- **Action:** When `break` is executed inside an `if` condition, control jumps completely outside the loop block. No further iterations will occur.
    
- **Context:** Works exactly like `break` in a `switch` statement.
    

```javascript
for (let i = 1; i <= 10; i++) {
    if (i === 5) {
        break; // exit loop completely when i is 5
    }
    console.log(i);
}
```

**Output:**

```
1
2
3
4
```

The loop stops at 5 and never prints further numbers.

---

### The `continue` Keyword

- **Function:** Skips the rest of the current iteration, but continues with the next one.
    
- **Action:** When triggered, it ignores the remaining code in the loop body for that iteration and jumps back to the **condition check**.
    
- **Difference from `break`:** `break` stops the loop entirely, while `continue` only skips a single cycle.
    

```javascript
for (let i = 1; i <= 10; i++) {
    if (i % 2 === 0) {
        continue; // skip even numbers
    }
    console.log(i);
}
```

**Output:**

```
1
3
5
7
9
```

Here, every time the loop encounters an even number, it skips printing and moves to the next iteration.

---

??? info "Where You’ll Use These"  
    - **`break`:** Useful when searching for something (stop once you’ve found it).  
    - **`continue`:** Useful when filtering data (skip unwanted cases but keep looping).

---

## Conclusion

We started this chapter by moving from **decision-making** (`if/else`, `switch`, ternary operators) into **repetition** with loops. Along the way, we covered not only the syntax of the `for` loop but also the reasoning behind why and when to use it.

### Key Takeaways

- **Loops = Iterations:** They allow us to repeat code efficiently instead of writing it multiple times.
    
- **The `for` Loop:**
    
    - Has three key parts: initialization, condition check, and update.
        
    - Execution flow feels “jumpy,” but follows a predictable cycle.
        
- **Control Inside Loops:**
    
    - We can embed `if` conditions to filter or branch behavior.
        
    - Nested loops let us handle multi-dimensional problems like grids or tables.
        
- **Arrays:** Loops integrate naturally with arrays, enabling us to access elements safely using `index < array.length`.
    
- **`break` and `continue`:**
    
    - `break` exits a loop completely.
        
    - `continue` skips only the current cycle and proceeds with the next.
        

### Practical Perspective

Loops are not just about printing patterns; they’re about:

- Iterating through **datasets**.
    
- Handling **user records** in applications.
    
- Processing **API responses** or **database rows**.
    
- Controlling logic flow efficiently in real-world scenarios.
    

By now, you should be comfortable not only writing loops but also knowing when to exit early, when to skip, and how to combine loops with conditions for maximum flexibility.

---
### Exercises

Try the following to reinforce today’s learning:

1. Write a `for` loop that prints numbers 1 to 20 but **stops** at 12 using `break`.
    
2. Write a `for` loop that prints numbers 1 to 15 but **skips** multiples of 3 using `continue`.
    
3. Use a nested loop to print a **5x5 multiplication grid**.
    
4. Create an array of names and use a `for` loop to print `"Welcome, <name>!"` for each.
    

---
