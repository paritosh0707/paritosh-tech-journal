> ⏱️ Estimated reading time: 15 min

# Control Flow in JavaScript

## Foundation Context

Up to this point, we have already built a strong foundation: we know how JavaScript handles its data types, variables, and basic execution behavior. With this understanding, we can now step into one of the most practical aspects of programming—**control flow**.

Every program, no matter how complex, ultimately boils down to a set of instructions. But execution doesn’t always follow a straight line from top to bottom. At some point, the program needs to **make decisions**:

- Should this piece of code run now?
    
- What happens if the condition is false?
    
- Should we repeat certain steps multiple times?
    

This decision-making ability is where control flow comes into play. And because we already understand the foundation of execution contexts and types, grasping control flow mechanisms will be straightforward.

---

## Defining Logic Control

**Control flow** (sometimes called _logic control_) is the system that dictates **which path a program takes during execution**.

Think of it like navigating a city. Instead of driving straight through every road, you stop at intersections. Based on conditions (traffic lights, signs, your destination), you either turn left, go straight, or stop. Similarly, in code, we often want different actions to happen depending on circumstances.

### Why Do We Need Control Flow?

Without control, a program would simply run every line from start to finish without discrimination. But in real-world scenarios:

- If a user is logged in, we want to show their dashboard.
    
- If they are logged out, we want to show a login form.
    

This branching of logic ensures that programs behave dynamically, adapting to different inputs and situations.

```javascript
let isLoggedIn = true;

if (isLoggedIn) {
  console.log("Welcome back, Paritosh!");
} else {
  console.log("Please log in to continue.");
}
```

In this short example, the output depends entirely on the value of `isLoggedIn`. This is the essence of control flow—**decisions based on conditions**.

---

??? info "Instructional Goal"  
	The objective here is to cover **all major control flow mechanisms in JavaScript** in one continuous explanation—`if`, `else`, `else if`, logical operators, `switch`, truthy/falsy values, and advanced operators like `??` and the ternary operator.  
	This way, you’ll see the entire spectrum of logical controls without scattered repetition across multiple sections.

---


## The Basic Conditional Statement: `if`

### Core Structure and Execution

The `if` statement is the most fundamental way to introduce **decision-making** into JavaScript. It acts as a simple gatekeeper: only when the specified condition is `true` will the code inside the block execute.

The general structure looks like this:

```javascript
if (condition) {
  // code inside this block executes only if condition is true
}
```

- The parentheses `( )` hold the **condition** to be evaluated.
    
- The curly braces `{ }` define the **scope** of code that will run when the condition passes.
    
- If the condition evaluates to `false`, the block is skipped entirely.
    

```javascript
let temperature = 45;

if (temperature < 50) {
  console.log("It’s a pleasant day outside!");
}
```

Here, because `temperature < 50` evaluates to `true`, the message is printed. If `temperature` were `60`, nothing inside the block would execute.

---

### Comparison Operators (Condition Evaluation)

Every `if` condition must ultimately boil down to a Boolean value—`true` or `false`. To reach that decision, JavaScript uses **comparison operators**.

#### Assignment vs. Comparison

- `=` is the **assignment operator**. It gives a value to a variable.
    
- To compare values, we use **comparison operators**, not `=`.
    

#### Core Comparison Operators

- **Less than `<`** and **greater than `>`**
    
    ```javascript
    console.log(5 < 10);  // true
    console.log(12 > 20); // false
    ```
    
- **Greater than or equal `>=`** and **less than or equal `<=`**  
    These allow a combined check (e.g., in trading systems, verifying if a stock price is at least a threshold).
    
    ```javascript
    console.log(100 >= 100); // true
    console.log(7 <= 10);    // true
    ```
    
- **Loose equality `==`**  
    Checks whether two values are equal, allowing type coercion.
    
    ```javascript
    console.log(2 == "2"); // true (number and string considered equal)
    ```
    
- **Not equal `!=`**  
    Checks whether values are not equal.
    
    ```javascript
    console.log(3 != 2); // true
    ```
    

---

### Strict Type Checking

JavaScript's flexibility can be both powerful and dangerous. Loose comparisons (`==`) sometimes give unexpected results because of **type coercion**. That's why strict operators exist.

- **Strict equality `===`**: Compares both value **and** type.
    
    ```javascript
    console.log(2 === "2"); // false (number vs. string)
    console.log(2 === 2);   // true
    ```
    
- **Strict inequality `!==`**: Ensures values and types are not the same.
    
    ```javascript
    console.log(2 !== 3);    // true
    console.log(2 !== "2");  // true
    ```
    

Strict checks are the **preferred practice** in modern JavaScript, as they eliminate ambiguity.

---

??? tip "Best Practice"  
	  Always use `===` and `!==` instead of `==` and `!=` unless you specifically want JavaScript’s type coercion. It keeps logic clearer and avoids subtle bugs.

## Scope Management and Structural Expansion

### Block Scope and Variable Safety

In JavaScript, **curly braces `{ }` do more than group code visually**—they create a **block scope**. Variables declared with `let` or `const` inside this scope are **restricted to it**.

```javascript
if (true) {
  let city = "Jaipur";
  console.log(city); // Jaipur
}

console.log(city); // ❌ ReferenceError: city is not defined
```

Here, the variable `city` exists only inside the `if` block. Attempting to access it outside leads to an error. Far from being a problem, this is a _feature_: it keeps our code safe and predictable by preventing accidental leaks of values into the global space.

#### The Problem with `var`

The older keyword `var` behaves differently. Variables declared with `var` are **function-scoped**, not block-scoped, meaning they "escape" from the curly braces:

```javascript
if (true) {
  var country = "India";
  console.log(country); // India
}

console.log(country); // ✅ India (accessible outside the block)
```

This behavior can cause bugs in larger programs because variables unintentionally overwrite or leak values. For this reason, `var` is generally **avoided** in modern JavaScript, replaced by `let` and `const`.

---

### Expanding Logic: `else` and `else if`

Once you understand `if`, the next step is to make it more flexible. This is where `else` and `else if` come in.

#### `if...else`

With `if...else`, one block executes _only if the condition is true_, and the other executes _only if the condition is false_. Both blocks can never run together.

```javascript
let temperature = 60;

if (temperature < 50) {
  console.log("Temp is less than 50");
} else {
  console.log("Temp is greater than or equal to 50");
}
```

This ensures mutual exclusivity: the program must choose one path.

---

#### `else if` (Nesting)

Sometimes we need more than two options. That's where `else if` fits in—allowing **multiple, mutually exclusive checks**.

```javascript
let balance = 800;

if (balance < 500) {
  console.log("Low balance");
} else if (balance < 750) {
  console.log("Average balance");
} else if (balance < 900) {
  console.log("Good balance");
} else {
  console.log("Excellent balance");
}
```

Here, only one block executes, even though multiple conditions are tested. The final `else` acts as the **catch-all** when none of the previous conditions are true.

---

### Short-hand Notation and Anti-Patterns

#### Implicit Scope (Shorthand)

If the conditional block contains **only one statement**, curly braces may be omitted:

```javascript
let score = 95;

if (score > 90) console.log("Outstanding performance!");
```

While this works, it should be used cautiously. For readability, braces `{}` are usually preferred, especially in collaborative codebases.

---

#### Anti-Pattern Warning

Avoid writing multiple statements without braces, even if technically allowed:

```javascript
// ❌ Bad practice
if (score > 90) console.log("High score"),
console.log("Awarding bonus points");
```

This kind of shorthand makes code **confusing, unreadable, and error-prone**. Professional developers consider it an **immature style**.

---

??? note "Key Takeaway"  
    - Use `let` and `const` for safe block scoping.  
    - Prefer braces `{}` even when writing a single-line condition.  
    - `else if` helps chain conditions, while `else` provides a catch-all.  
    - Avoid anti-pattern shorthand that sacrifices clarity for brevity.

---

## Combining Conditions (Logical Operators)

So far, we've dealt with single conditions: _if this, then that._ But real-world scenarios often require **multiple checks at the same time**. JavaScript provides **logical operators** to combine conditions and make decisions more precise.

---

### Logical AND Operator (`&&`)

The `&&` operator ensures that **all listed conditions must evaluate to `true`** before the code executes.

```javascript
let isLoggedIn = true;
let hasDebitCard = true;

if (isLoggedIn && hasDebitCard) {
  console.log("Access granted: You can purchase the course.");
}
```

- If `isLoggedIn` is `true` **and** `hasDebitCard` is `true`, the block runs.
    
- If even one condition is `false`, the block is skipped.
    

This is especially useful in **multi-factor checks**, like granting course access only if a user has logged in **and** has a valid payment method.

---

### Logical OR Operator (`||`)

The `||` operator means that **only one of the listed conditions needs to be `true`** for the block to execute.

```javascript
let loginWithGoogle = false;
let loginWithEmail = true;

if (loginWithGoogle || loginWithEmail) {
  console.log("User can log in.");
}
```

Here:

- If either `loginWithGoogle` or `loginWithEmail` is true, the code runs.
    
- The block executes as long as **at least one condition is satisfied**.
    

This operator is often used for **flexibility in access control**, such as:

- Logging in with Google **or** email.
    
- Showing a **logout** button if the user is logged in **or** has a valid token.
    

---

??? info "Operator Recap"  
  - `&&` → All conditions must be true.  
  - `||` → At least one condition must be true.

---
Here’s the **MkDocs-ready content** for **Section V: The Switch Statement**, written in a clear, teacher-like flow.

---

## The Switch Statement

### Rationale

The `switch` statement provides an elegant alternative to **long chains of `if...else if` conditions**.

It is best suited when you need to evaluate **a single value** (the _key_) against multiple possible cases. Instead of stacking comparisons line by line, `switch` organizes them neatly in one block.

For example:

- Checking a **month number** (1 → January, 2 → February, …).
    
- Mapping a **user rating** to a response.
    
- Handling **action types** in frameworks like Redux.
    

---

### Syntax and Mechanics

The general structure of `switch` looks like this:

```javascript
switch (key) {
  case value1:
    // code to execute if key === value1
    break;

  case value2:
    // code to execute if key === value2
    break;

  default:
    // code to execute if no case matches
}
```

- **`key`** → the variable being tested.
    
- **`case`** → each possible match is written as a case.
    
- **`break`** → stops further execution once a case matches.
    
- **`default`** → executes if no case matches.
    

Example: Checking a month number.

```javascript
let month = 3;

switch (month) {
  case 1:
    console.log("January");
    break;
  case 2:
    console.log("February");
    break;
  case 3:
    console.log("March");
    break;
  default:
    console.log("Invalid month");
}
```

Output:

```
March
```

Notice how much cleaner this looks compared to multiple `else if` statements.

---

### Controlling Flow: `break` and `default`

#### The Waterfall Effect

In JavaScript, once a case matches, the program continues executing **all subsequent cases** unless explicitly stopped. This is called the **waterfall effect**.

```javascript
let rating = 2;

switch (rating) {
  case 1:
    console.log("Poor");
  case 2:
    console.log("Average");
  case 3:
    console.log("Good");
  default:
    console.log("Invalid rating");
}
```

Output:

```
Average
Good
Invalid rating
```

This happened because there were no `break` statements to stop execution after a match.

---

#### The `break` Keyword

To avoid unwanted waterfalls, always use `break` after handling a case:

```javascript
let rating = 2;

switch (rating) {
  case 1:
    console.log("Poor");
    break;
  case 2:
    console.log("Average");
    break;
  case 3:
    console.log("Good");
    break;
  default:
    console.log("Invalid rating");
}
```

Output:

```
Average
```

Now only the intended case runs.

---

#### The `default` Keyword

If none of the cases match, the `default` block runs. It acts as the **catch-all**, ensuring your program responds gracefully to unexpected values.

```javascript
let month = 13;

switch (month) {
  case 1:
    console.log("January");
    break;
  case 2:
    console.log("February");
    break;
  default:
    console.log("Invalid month");
}
```

Output:

```
Invalid month
```

Unlike cases, the `default` block executes only when no other case matches—it does not fall through.

---

??? tip "Best Practice"  
    - Use `switch` when comparing one variable against many options.  
    - Always include `break` to prevent unintended execution.  
    - Always provide a `default` case as a fallback.

---

## Truthy and Falsy Values

### Defining the Concept

Not all values in JavaScript are strictly `true` or `false`. Yet, when placed inside a **conditional context**—like an `if` statement—JavaScript automatically evaluates them as either **truthy** or **falsy**.

Think of it this way: JavaScript tries to “guess” whether a value should count as **something** (`true`) or **nothing** (`false`).

Example:

```javascript
if ("Paritosh") {
  console.log("This runs, because a non-empty string is truthy.");
}

if ("") {
  console.log("This will not run, because an empty string is falsy.");
}
```

---

### List of Falsy Values

Only a handful of values are considered **falsy** in JavaScript. Everything else is truthy.

- `false` (literal Boolean)
    
- `0` (zero)
    
- `-0` (negative zero)
    
- `0n` (BigInt zero)
    
- `""` (empty string)
    
- `null`
    
- `undefined`
    
- `NaN` (Not a Number)
    

```javascript
if (0) {
  console.log("Will not run");
}

if (null) {
  console.log("Will not run");
}
```

---

### Key Truthy Values

Every other value not on the falsy list is **truthy**. But here's where JavaScript gets tricky—some values _look_ falsy but are actually truthy. These often appear in **interview questions**:

- `"0"` → A string containing zero is truthy.
    
- `"false"` → A string containing `"false"` is truthy (it’s still a non-empty string).
    
- `" "` → A string with just a space is truthy.
    
- `[]` → An empty array is truthy.
    
- `{}` → An empty object is truthy.
    
- `function() {}` → An empty function is also truthy.
    

```javascript
if ("0") {
  console.log("Runs, because '0' (string) is truthy.");
}

if ([]) {
  console.log("Runs, because [] is truthy.");
}
```

---

### Loose Equality Notes

Things get even more confusing with **loose equality (`==`)** because of type coercion:

```javascript
console.log(false == 0);   // true
console.log(false == "");  // true
console.log(0 == "");      // true
```

This is why professional developers almost always prefer **strict equality (`===`)** to avoid such unexpected results.

---

??? note "Key Takeaway"  
    - Only 7 falsy values exist: `false`, `0`, `-0`, `0n`, `""`, `null`, `undefined`, `NaN`.  
    - Everything else is truthy—even empty arrays, empty objects, and non-empty strings like `"false"`.  
    - Avoid loose equality traps; use `===` for reliability.


---

## Safety Checks for Complex Data

### Checking for Empty Arrays

One of the biggest surprises for beginners is that **empty arrays are truthy**.

```javascript
if ([]) {
  console.log("This runs, even though the array is empty!");
}
```

This means that using an empty array directly in a condition is unreliable. Instead, we need to check whether the array contains any elements.

#### Recommended Method

The safe way is to check the **`.length` property**:

```javascript
let items = [];

if (items.length === 0) {
  console.log("Array is empty.");
} else {
  console.log("Array has elements.");
}
```

- `.length` returns the number of elements in the array.
    
- Comparing it strictly with `0` gives a clear, reliable result.
    

---

### Checking for Empty Objects

Similar to arrays, **empty objects are also truthy**:

```javascript
if ({}) {
  console.log("This runs, even though the object is empty!");
}
```

A direct check won’t work. Instead, we must inspect the object’s keys.

#### Recommended Method

Use `Object.keys()`, which returns an array of the object's keys. If that array is empty, the object has no properties.

```javascript
let user = {};

if (Object.keys(user).length === 0) {
  console.log("Object is empty.");
} else {
  console.log("Object has properties.");
}
```

This technique is reliable and widely used in real-world code, especially when validating API responses or checking database results.

---

??? tip "Best Practice"  
    - **For arrays:** Always check `.length === 0`.  
    - **For objects:** Use `Object.keys(obj).length === 0`.  
    - Never rely on direct `if (array)` or `if (object)` checks—they will always pass, even when empty.

---

Do you want me to now move on to **Section VIII: Advanced Control Operators (Handling Missing Values)**, or should I enrich this section with a **practical applied example** (like checking if a shopping cart or user profile is empty) before proceeding?


Here’s the **MkDocs-ready content** for **Section VIII: Advanced Control Operators (Handling Missing Values)**, expanded with clear explanations and examples.

---

## Advanced Control Operators (Handling Missing Values)

As programs grow, we often need compact ways to handle **missing values** or write **concise conditional logic**. JavaScript provides two powerful operators for these scenarios: the **Nullish Coalescing Operator (`??`)** and the **Ternary Operator (`? :`)**.

---

### The Nullish Coalescing Operator (`??`)

#### Goal

The `??` operator is specifically designed to provide a **fallback value** when the primary value is either **`null` or `undefined`**.

This makes it safer than the logical OR (`||`), which treats many falsy values (like `0` or `""`) as triggers for fallback.

---

#### Context

This operator is especially useful when working with:

- Values returned from **databases**.
    
- Responses from **third-party APIs** (like Firebase or Appwrite).
    
- Functions that may return `null` or `undefined`.
    

---

#### Mechanism

If the value on the left side of `??` is `null` or `undefined`, the expression returns the right-hand value.

```javascript
let userName = null;
let defaultName = "Guest";

let displayName = userName ?? defaultName;
console.log(displayName); // Guest
```

- Because `userName` is `null`, the fallback `"Guest"` is used.
    

Compare this with `||`:

```javascript
let count = 0;

console.log(count || 10); // 10 (treats 0 as falsy)
console.log(count ?? 10); // 0 (respects 0 as valid)
```

---

#### Best Practice

Whenever possible, assign a **known fallback value** instead of allowing `null` or `undefined` to propagate in your logic.

```javascript
let isActive = response.isActive ?? false;
```

This ensures your program behaves predictably without unexpected “empty” states.

---

### The Ternary Operator (`? :`)

#### Goal

The ternary operator provides a **compact, single-line syntax** for simple `if...else` conditions. It’s often used for quick assignments or inline logic.

---

#### Syntax

```javascript
condition ? true_statement : false_statement
```

---

#### Example

```javascript
let score = 85;
let result = score >= 50 ? "Pass" : "Fail";

console.log(result); // Pass
```

Here:

- If the condition (`score >= 50`) is true, `"Pass"` is assigned.
    
- Otherwise, `"Fail"` is assigned.
    

---

#### Distinction from `??`

It's important not to confuse the ternary operator with `??`.

- **`??`** checks specifically for `null` or `undefined`.
    
- **`?:`** checks a condition and returns one of two values.
    

```javascript
let value = null;

console.log(value ?? "Default");   // "Default" → nullish check
console.log(value ? "Yes" : "No"); // "No" → conditional check
```

---

??? note "Key Takeaway"  
    - Use `??` when you want **safe fallbacks** for `null` or `undefined`.  
    - Use `?:` when you want **concise conditional branching**.  
    - Do not confuse the two—they solve different problems.


---

Do you want me to proceed with **Section IX: Conclusion and Summary**, or would you like me to first add a **real-world mini example** (like user profile display with `??` and grading logic with `?:`) before wrapping up?

Here’s the **MkDocs-ready content** for **Section IX: Conclusion and Summary**, wrapping up the chapter in a teacher-like tone.

---

## Conclusion and Summary

### Recap of Control Flow Mastery

In this chapter, we explored the **complete set of control flow mechanisms in JavaScript**—the tools that let our programs make decisions, branch into different paths, and handle uncertainty gracefully.

By now, you should be comfortable with:

- **Conditional execution with `if`** → Running code only when a condition is true.
    
- **Comparison operators** → Understanding the difference between `=`, `==`, and `===`, and why strict equality is safer.
    
- **Scope management** → Using `let` and `const` to keep variables safe inside block scopes.
    
- **Logical operators (`&&`, `||`)** → Combining conditions for multi-factor or flexible checks.
    
- **The `switch` statement** → A cleaner alternative to long chains of `if...else if`.
    
- **Truthy and falsy values** → Recognizing how JavaScript interprets non-Boolean values in conditionals.
    
- **Safety checks for arrays and objects** → Ensuring reliability when working with potentially empty data.
    
- **Advanced operators (`??` and `?:`)** → Handling missing values and writing concise inline conditions.
    

Together, these mechanisms form the backbone of **logical control in JavaScript**. They transform code from a rigid sequence of instructions into a dynamic system that responds to different inputs and states.

---

??? tip "Looking Ahead"  
    Control flow is now fully in your toolkit. In the next sections of the book, we’ll build on this foundation by exploring **loops and iterations**, followed by more advanced JavaScript features. As we move into projects, you’ll see how these concepts directly power real-world workflows like authentication, data validation, and conditional rendering.

---

Do you want me to now create a **set of practice exercises** for this chapter (with small coding tasks and challenges), or should we directly move on to the next topic in your outline?


Perfect — here’s the **Exercises section** for this chapter, written in MkDocs style with progressive difficulty.

---

## Exercises: Control Flow in JavaScript

Strengthening your understanding comes from practice. The following exercises will help you apply everything we covered in this chapter.

---

### 1. Simple `if` Check

Write a program that checks if a number stored in the variable `age` is greater than or equal to 18.

- If true, print `"Eligible to vote"`.
    
- Otherwise, print `"Not eligible"`.
    

---

### 2. Strict vs. Loose Equality

Try the following comparisons in JavaScript:

```javascript
console.log(2 == "2");
console.log(2 === "2");
console.log(false == 0);
console.log(false === 0);
```

- Predict the output before running.
    
- Explain why the results differ.
    

---

### 3. Temperature Categories

Use `if...else if...else` to categorize a variable `temperature`:

- Below 20 → `"Cold"`
    
- 20–30 → `"Moderate"`
    
- Above 30 → `"Hot"`
    

---

### 4. Multi-Factor Login Check

Simulate login validation with two variables:

```javascript
let isLoggedIn = true;
let hasToken = false;
```

- Only print `"Access granted"` if both are true.
    
- If either is missing, print `"Access denied"`.
    

---

### 5. Switch Case: Day of the Week

Create a `switch` statement that prints the day name (`Monday`, `Tuesday`, etc.) based on a number from 1 to 7.

- Use `default` to handle invalid numbers.
    

---

### 6. Truthy/Falsy Quiz

Predict the output before running this code:

```javascript
if ("0") console.log("Case 1 runs");
if ([]) console.log("Case 2 runs");
if ("") console.log("Case 3 runs");
if (null) console.log("Case 4 runs");
```

Explain why each case does or does not run.

---

### 7. Empty Data Checks

Write a function that:

- Takes an array as input.
    
- Prints `"Empty array"` if it has no elements, otherwise `"Array has items"`.
    

Then, modify the function to handle objects using `Object.keys()`.

---

### 8. Using `??` (Nullish Coalescing)

Create a variable `userName` that is `null`.

- Use `??` to assign `"Guest"` as the fallback.
    
- Print the result.
    

Repeat the same with a variable set to `0` and see how `??` differs from `||`.

---

### 9. Ternary Operator

Using a single line, assign `"Pass"` or `"Fail"` to a variable `result` based on whether a score (say `65`) is greater than or equal to 50.

---

### 10. Mini Challenge

Simulate a shopping checkout flow:

- A user can buy a course only if they are logged in **and** have payment enabled.
    
- If they are logged in but payment is missing, print `"Add payment method"`.
    
- If they are not logged in, print `"Please log in"`.
    

Use a combination of `if...else`, `&&`, and `||` to solve this.

---

??? tip "How to Practice"  
    - First, **predict the output** mentally before running the code.  
    - Then, run it in Node.js or browser console.  
    - Finally, **explain the result** in your own words—this step builds deep understanding.

---
