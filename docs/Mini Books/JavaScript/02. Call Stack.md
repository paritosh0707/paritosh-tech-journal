> ⏱️ Estimated reading time: 15 min

## Fundamentals of JavaScript Code Execution

When we write JavaScript, we usually think in terms of variables, functions, loops, and conditions. But beneath the surface, JavaScript has a very strict way of handling the execution of this code.

Unlike some languages that run multiple threads at the same time, **JavaScript is single-threaded**. This means only **one thing happens at a time**, and that “one thing” follows an organized set of rules inside the JavaScript Engine (like V8 in Chrome or Node.js).

At the heart of this process are two key ideas:

1. **Execution Context** – the environment where code actually runs.
    
2. **Call Stack** – the structure that manages which code is currently running, and in what order.
    

These two work together to make sure JavaScript knows **where it is in your program** and what needs to happen next.

??? info "Why does this matter?"  
    Think of JavaScript as a busy kitchen. The **Execution Context** is like one chef’s workstation — all their tools, ingredients, and current dish. The **Call Stack** is the ticket board, keeping track of which order is being cooked right now and which one comes after. Without both, the kitchen would collapse into chaos.

### Two Phases of Execution

Every time JavaScript runs your code, it doesn’t just plow through line by line. Instead, it carefully divides execution into **two distinct phases**:

1. **Memory Creation Phase (Setup)** – JavaScript prepares memory space for variables and functions before executing anything.
    
2. **Execution Phase (Running the Code)** – JavaScript goes through the code line by line, assigns values, performs calculations, and calls functions.
    

This **two-phase model** is the backbone of how even the simplest code works.

```javascript
// Example: A simple script
let val1 = 10;
let val2 = 5;

function addNum(a, b) {
    return a + b;
}

let result = addNum(val1, val2);
console.log(result);  // Output: 15
```

Before JavaScript even starts adding numbers, it will first **scan and prepare memory** for `val1`, `val2`, and `addNum`. Only in the second phase does it actually compute `15`.

!!! note "Common Misconception"  
	Many beginners think JavaScript runs from **top to bottom in one go**.  
	In reality, the engine first **allocates memory and registers functions**, and only afterward begins actual execution. Missing this point leads to confusion about concepts like _hoisting_.

---

## JavaScript Execution Contexts

To truly understand how JavaScript runs code, we need to look at the **Execution Context** — the environment in which code is evaluated and executed. Every time you run a script, JavaScript creates an execution context to manage the variables, functions, and rules that apply during execution.

### A. Definition and Operation

An **Execution Context** is like a _container_ or _workspace_ that holds everything JavaScript needs to execute a piece of code. It decides **what variables are accessible**, **what value `this` has**, and **how function calls are handled**.

Key points:

- JavaScript is **single-threaded**. Only one execution context runs at a time.
    
- Code is executed **sequentially** — one instruction after another — unless functions or asynchronous operations introduce delays or callbacks.
    

??? info "Think of it this way"  
	Imagine a theater stage. Each play (your script or function) gets its own stage setup — props, actors, lighting. That’s the **Execution Context**. Only one play is performed at a time, but new plays can start when called, and old ones exit once finished.

---

### B. Types of Execution Contexts

JavaScript recognizes three main types of execution contexts:

1. **Global Execution Context (GEC)**
    
    - Created automatically when your program starts.
        
    - There can only be **one global context** per program.
        
2. **Function Execution Context (FEC)**
    
    - Created whenever a function is invoked.
        
    - Each function call generates a **new context**, independent from others.
        
3. **Eval Execution Context**
    
    - Created when code is run inside the `eval()` function.
        
    - Rarely used in modern code (considered bad practice because of security and performance concerns).
        

```javascript
// Example to trigger different execution contexts
let name = "Paritosh";   // Global Execution Context (GEC)

function greet() {       // Function Execution Context (FEC)
    let msg = "Hello " + name;
    console.log(msg);
}

greet();  // creates a new FEC
```

Here:

- The `name` variable exists in the **GEC**.
    
- When `greet()` is called, JavaScript creates a **new FEC**(Functional Execution Context) for it.
    
- Once `greet()` finishes, its context is destroyed and control goes back to the **GEC**.
    

---

### C. Global Execution Context (GEC) Details

The **Global Execution Context** is the first context created when a JavaScript program runs. It acts as the “base environment.”

- The keyword **`this`** refers to the global object inside the GEC.
    
- In a **browser environment**, this global object is the **`window`**.
    
- In **Node.js**, the global object is **`global`** (or `globalThis` in modern environments).
    
- In **Bun** (another JavaScript runtime), it’s also `globalThis`.
    

```javascript
// Browser Example
console.log(this); 
// Output: window object

// Node.js Example
console.log(this); 
// Output: {} (empty object in module scope, but globalThis is the true global)
console.log(globalThis); 
// Output: global object
```

!!! note "Environment Differences"  
    Don’t assume `this` always points to `window`. Its value depends on the **execution environment**.  
    * Browser: `this === window` in global scope.  
    * Node.js: `this` at the top-level file scope is `{}`, not the global object.

---

## The Two Execution Phases

Every **Execution Context** in JavaScript (whether Global or Function) is processed in **two distinct phases**. This two-step mechanism ensures that JavaScript knows about all variables and functions before it starts actually executing statements.

---

### A. Phase 1: Memory Creation Phase

Also known as the **Creation Phase** or **Memory Phase**, this is when JavaScript prepares memory space for your code.

Key behaviors in this phase:

- **Variables** are allocated memory but initialized with the value `undefined`.
    
- **Functions** are stored with their full definition, not just `undefined`.
    
- **No execution of actual logic** (like arithmetic or assignments) happens here.
    

```javascript
// Example code
let val1 = 10;
let val2 = 5;

function addNum(a, b) {
    return a + b;
}

let result = addNum(val1, val2);
```

During the **Memory Creation Phase**, JavaScript sets up memory like this:

```
val1 -> undefined
val2 -> undefined
addNum -> function definition
result -> undefined
```

??? info "Why assign `undefined`?"  
    JavaScript uses `undefined` as a placeholder to ensure that all variables are known in advance.  
    This is the reason behind **hoisting**, where variables and function declarations are conceptually “moved” to the top of their scope.

---

### B. Phase 2: Execution Phase

Once memory allocation is complete, JavaScript begins the **Execution Phase** — actually running the code line by line.

Key behaviors in this phase:

- **Variables** are assigned their actual values.
    
- **Functions** are executed when called.
    
- **Expressions, loops, and conditions** are processed.
    

For our example:

1. `val1 = 10`
    
2. `val2 = 5`
    
3. `addNum` is already defined, so when called:
    
    - A new Function Execution Context (FEC) is created.
        
    - Inside it, arguments `a = 10`, `b = 5` → function returns `15`.
        
4. `result = 15`
    
5. `console.log(result)` prints **15**.
    

!!! note "Common Beginner Mistake"  
    Many developers confuse **declaration** with **assignment**.  
    In JavaScript, variables are _declared and initialized with `undefined`_ in the Creation Phase, and only later _assigned_ their intended values in the Execution Phase.

---

## Detailed Function Execution Flow

Every time you **call a function**, JavaScript doesn’t just “jump” into the function. Instead, it carefully creates a **new isolated environment** called a **New Execution Context (NEC)**. This ensures that variables inside the function don’t interfere with global variables or other functions.

---

### A. Function Call Trigger

When a function is invoked (e.g., `addNum(val1, val2)`), JavaScript:

1. Creates a **New Execution Context (NEC)** for that function.
    
2. Sets up:
    
    - A **New Variable Environment** (like a private sandbox).
        
    - An **Execution Thread** to run the function code.
        

```javascript
let val1 = 10;
let val2 = 5;

function addNum(a, b) {
    let total = a + b;
    return total;
}

let result = addNum(val1, val2);  // function call triggers NEC
console.log(result);
```

At the line `addNum(val1, val2)`, JavaScript builds a fresh execution context just for `addNum`.

---

### B. Execution within the Function Context (NEC)

Just like the **Global Execution Context (GEC)**, the NEC also runs through **two phases**:

1. **Memory Creation Phase (inside function)**
    
    - Arguments `a` and `b` are initialized with `undefined`.
        
    - Local variable `total` is also set to `undefined`.
        
    - Function body is registered.
        
    
    ```
    a -> undefined
    b -> undefined
    total -> undefined
    ```
    
2. **Execution Phase (inside function)**
    
    - `a = 10`, `b = 5` (values passed from the global scope).
        
    - `total = a + b = 15`.
        
    - `return total` sends back `15`.
        

---

### C. Return and Cleanup

Once the function finishes:

- The **result** (`15`) is returned to the **parent context** (in this case, the GEC).
    
- The **New Execution Context (NEC)** is then **completely deleted**.
    
- If the function is called again, a **fresh NEC** is created — nothing is remembered from the old one.
    

```javascript
console.log(addNum(20, 30));  // 50 (new NEC created)
console.log(addNum(100, 200)); // 300 (another NEC created)
```

Each call runs in a clean, isolated environment.
    

!!! note "Important"  
    _Every function call gets its own fresh Execution Context._  
    That’s why local variables inside functions don’t clash with each other or with global variables.

---

## The Call Stack

Now that we understand how Execution Contexts are created and destroyed, the next question is: **how does JavaScript keep track of all of them?**

The answer is the **Call Stack** — a simple but powerful data structure that manages the order of execution.

---

### A. Structure and Flow

The **Call Stack**:

- Is a stack data structure provided by the JavaScript engine.
    
- Always starts with the **Global Execution Context (GEC)**.
    
- Pushes a new function’s Execution Context onto the stack whenever a function is called.
    
- Pops (removes) the function’s Execution Context once it finishes.
    

```javascript
function first() {
    console.log("Inside first()");
    second();
}

function second() {
    console.log("Inside second()");
}

first();
console.log("End of program");
```

**How the Call Stack looks step by step:**

1. Start → GEC created (`main program`).
    
2. `first()` is called → `first()` context is **pushed**.
    
3. Inside `first()`, `second()` is called → `second()` context is **pushed**.
    
4. `second()` finishes → `second()` context is **popped**.
    
5. `first()` finishes → `first()` context is **popped**.
    
6. Only GEC remains until the program ends.
    

---

### B. LIFO Principle

The Call Stack follows the **Last In, First Out (LIFO)** rule:

- The last function pushed onto the stack is always the **first to finish and get removed**.
    
- This guarantees order in nested or chained function calls.
    

```javascript
function one() {
    two();
}
function two() {
    three();
}
function three() {
    console.log("Inside three()");
}

one();
```

**Call Stack progression:**

1. GEC created.
    
2. `one()` called → push `one()`.
    
3. `two()` called → push `two()`.
    
4. `three()` called → push `three()`.
    
5. `three()` finishes → pop `three()`.
    
6. `two()` finishes → pop `two()`.
    
7. `one()` finishes → pop `one()`.
    
8. End → only GEC remains.
    

---

!!! note "Key Takeaway"  
	The Call Stack is the **backbone of synchronous JavaScript execution**. Understanding it is essential for debugging recursion, stack overflows, and async behavior (where the **Event Loop** interacts with the stack — something we’ll explore later).

---

## Visualization Using Browser Tools

So far, we’ve explored the **theory** of Execution Contexts and the Call Stack. But the best way to truly understand them is by **watching them in action**. Modern browsers like **Chrome** or **Edge** provide excellent tools for this.

---

### Using Chrome DevTools (Step by Step)

1. **Open DevTools**
    
    - Right-click anywhere on a page → **Inspect** → go to the **Sources** tab.
        
2. **Create a Snippet**
    
    - In the left sidebar, find **Snippets**.
        
    - Click `+ New Snippet` and paste your JavaScript code.
        
    
    ```javascript
    function first() {
        second();
    }
    function second() {
        third();
    }
    function third() {
        console.log("Inside third()");
    }
    first();
    ```
    
3. **Set Breakpoints**
    
    - Click on the line numbers (e.g., where `first()` or `second()` is called).
        
    - This tells the debugger to pause execution at that point.
        
4. **Run the Snippet**
    
    - Right-click → **Run**.
        
    - Execution pauses at the first breakpoint.
        
5. **Observe the Call Stack Panel**
    
    - On the right side, open the **Call Stack panel**.
        
    - You’ll see:
        
        - At the start → only `Global Execution Context`.
            
        - As functions get called → `first`, `second`, `third` appear on top of the stack.
            
        - As functions return → they disappear one by one, proving the **LIFO principle**.
            


---

### Why This Matters for Developers

- **Debugging:** Helps identify where code is currently paused and what sequence of calls led there.
    
- **Recursion:** Easily track deep recursive calls and detect infinite loops or stack overflows.
    
- **Understanding Async:** In later chapters (Event Loop, Promises, Async/Await), you’ll see how DevTools separates the **Call Stack** from the **Task Queue**, making it an invaluable learning and debugging tool.
    

!!! tip "Pro Practice"  
    Whenever you’re confused about how your code executes, don’t just guess. **Step through it in the debugger** and watch the Call Stack change in real time.

---

## Summary & Exercises

### Key Takeaways

- **Execution Context** is the environment where JavaScript code runs.
    
    - Global Execution Context (GEC) is created first.
        
    - Each function call creates a fresh Function Execution Context (FEC).
        
    - `eval()` also has its own context, though rarely used.
        
- Each Execution Context runs in **two phases**:
    
    1. **Memory Creation Phase** – variables assigned `undefined`, functions stored with full definition.
        
    2. **Execution Phase** – variables get actual values, code executes line by line.
        
- **Function Execution Flow**:
    
    - New Execution Context (NEC) created on each call.
        
    - Memory setup → Execution → Return result → Context deleted.
        
- **The Call Stack**:
    
    - Manages Execution Contexts using **Last In, First Out (LIFO)**.
        
    - GEC is always at the bottom.
        
    - Functions are pushed when called, popped when finished.
        
- **Visualization with Browser Tools**:
    
    - Using Chrome DevTools, you can set breakpoints, step through code, and observe the Call Stack live.
        

---

### Exercises

1. **Memory Creation Practice**  
    Predict the output:
    
    ```javascript
    console.log(num);
    var num = 20;
    function show() {
        console.log("Inside show");
    }
    show();
    ```
    
    _Hint: Think about how variables and functions are stored in the Memory Creation Phase._
    

---

2. **Call Stack Tracing**  
    Write down the order in which functions enter and leave the Call Stack:
    
    ```javascript
    function a() {
        b();
        console.log("End of a");
    }
    function b() {
        c();
        console.log("End of b");
    }
    function c() {
        console.log("End of c");
    }
    a();
    ```
    

---

3. **Function Context Cleanup**  
    Run this code and observe memory in DevTools:
    
    ```javascript
    function counter() {
        let x = 0;
        x++;
        return x;
    }
    
    console.log(counter()); // ?
    console.log(counter()); // ?
    console.log(counter()); // ?
    ```
    
    _Question: Why does each call return `1` instead of increasing further?_
    

---

4. **Debugging Hands-On**  
    Open Chrome DevTools → **Sources** tab → create a snippet with nested functions.  
    _Set breakpoints and watch the Call Stack panel._  
    _Note down the sequence of stack changes as you step through execution._
    

---

By practicing these exercises, you’ll solidify your understanding of how JavaScript **executes code step by step** and how the **Call Stack governs control flow**.

---

